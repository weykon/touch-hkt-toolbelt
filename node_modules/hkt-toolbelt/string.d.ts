import { Cast, Conditional, Kind, List } from ".";
export declare type _$startsWith<Prefix extends string, S extends string> = S extends `${Prefix}${string}` ? true : false;
export declare abstract class StartsWith<Prefix extends string> extends Kind {
    abstract f: (x: Cast<this[Kind._], string>) => _$startsWith<Prefix, typeof x>;
}
export declare type _$endsWith<Suffix extends string, S extends string> = S extends `${string}${Suffix}` ? true : false;
export declare abstract class EndsWith<Suffix extends string> extends Kind {
    abstract f: (x: Cast<this[Kind._], string>) => _$endsWith<Suffix, typeof x>;
}
export declare type _$includes<Infix extends string, S extends string> = S extends `${string}${Infix}${string}` ? true : false;
export declare abstract class Includes<Infix extends string> extends Kind {
    abstract f: (x: Cast<this[Kind._], string>) => _$includes<Infix, typeof x>;
}
export declare type _$append<Suffix extends string, S extends string> = `${S}${Suffix}`;
export declare abstract class Append<Suffix extends string> extends Kind {
    abstract f: (x: Cast<this[Kind._], string>) => _$append<Suffix, typeof x>;
}
export declare type _$prepend<Prefix extends string, S extends string> = `${Prefix}${S}`;
export declare abstract class Prepend<Prefix extends string> extends Kind {
    abstract f: (x: Cast<this[Kind._], string>) => _$prepend<Prefix, typeof x>;
}
declare type _$simpleSplit<S extends string, O extends string[] = []> = string extends S ? [string] : S extends `${infer Head}${infer Tail}` ? _$simpleSplit<Tail, [...O, Head]> : O;
export declare type _$isTemplate<S extends string> = string extends S ? false : List._$some<Conditional.Equals<string>, _$simpleSplit<S>>;
export declare abstract class IsTemplate extends Kind {
    abstract f: (x: Cast<this[Kind._], string>) => _$isTemplate<typeof x>;
}
export declare type _$join<T extends string[], D extends string = ""> = List._$isVariadic<T> extends true ? string : T extends [infer Head, ...infer Tail] ? Tail extends [] ? Head : `${Cast<Head, string>}${D}${_$join<Cast<Tail, string[]>, D>}` : string[] extends T ? string : "";
export declare abstract class Join<D extends string = ""> extends Kind {
    abstract f: (x: Cast<this[Kind._], string[]>) => _$join<typeof x, D>;
}
export declare type _$split<S extends string, Delimiter extends string = ""> = _$isTemplate<Delimiter> extends true ? string[] : string extends Delimiter ? string[] : S extends `${infer Head}${Delimiter}${infer Tail}` ? [Head, ..._$split<Tail, Delimiter>] : S extends Delimiter ? [] : [S];
export declare abstract class Split<Delimiter extends string = ""> extends Kind {
    abstract f: (x: Cast<this[Kind._], string>) => _$split<typeof x, Delimiter>;
}
export declare type _$first<S extends string> = S extends `${infer Head}${string}` ? Head : string extends S ? S : "";
export declare abstract class First extends Kind {
    abstract f: (x: Cast<this[Kind._], string>) => _$first<typeof x>;
}
export declare type _$last<S extends string> = S extends `${string}${infer Tail}` ? Tail extends "" ? S : _$last<Tail> : string extends S ? S : "";
export declare abstract class Last extends Kind {
    abstract f: (x: Cast<this[Kind._], string>) => _$last<typeof x>;
}
export * as String from "./string";
