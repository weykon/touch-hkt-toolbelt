import $, { Cast, Function, List } from ".";
export declare namespace Kind {
    const _: unique symbol;
    type _ = typeof _;
    type _$compose<FX extends Kind[], X> = FX extends [
        ...infer Init,
        infer Last
    ] ? _$compose<Cast<Init, Kind[]>, $<Cast<Last, Kind>, Cast<X, InputOf<Cast<Last, Kind>>>>> : X;
    type _$composablePair<F extends [Kind, Kind]> = Kind.OutputOf<F[1]> extends Kind.InputOf<F[0]> ? true : false;
    abstract class ComposablePair extends Kind {
        abstract f: (x: Cast<this[Kind._], [Kind, Kind]>) => _$composablePair<typeof x>;
    }
    type _$composable<FX extends Kind[]> = List._$every<Kind.ComposablePair, List._$pair<FX>>;
    abstract class Composable extends Kind {
        abstract f: (x: Cast<this[Kind._], Kind[]>) => _$composable<typeof x>;
    }
    abstract class Compose<FX extends _$composable<FX> extends true ? Kind[] : never> extends Kind {
        abstract f: (x: Cast<this[Kind._], FX extends [] ? unknown : InputOf<List._$last<FX>>>) => _$compose<FX, typeof x>;
    }
    type _$pipe<FX extends Kind[], X> = _$compose<List._$reverse<FX>, X>;
    abstract class Pipe<FX extends _$composable<List._$reverse<FX>> extends true ? Kind[] : never> extends Kind {
        abstract f: (x: Cast<this[Kind._], FX extends [] ? unknown : InputOf<List._$first<FX>>>) => _$pipe<FX, typeof x>;
    }
    abstract class Apply<X> extends Kind {
        abstract f: (x: Cast<this[Kind._], Kind<(x: X) => unknown>>) => $<typeof x, Cast<X, InputOf<typeof x>>>;
    }
    type InputOf<F extends Kind> = F extends {
        f: (x: infer X) => unknown;
    } ? X : unknown;
    type OutputOf<F extends Kind> = F extends {
        f: (x: never) => infer X;
    } ? X : unknown;
}
export declare const Composable: typeof Kind.Composable;
export declare type Composable = Kind.Composable;
export declare const Compose: typeof Kind.Compose;
export declare type Compose<FX extends Kind._$composable<FX> extends true ? Kind[] : never> = Kind.Compose<FX>;
export declare const Pipe: typeof Kind.Pipe;
export declare type Pipe<FX extends Kind._$composable<List._$reverse<FX>> extends true ? Kind[] : never> = Kind.Pipe<FX>;
export declare const Apply: typeof Kind.Apply;
export declare type Apply<X> = Kind.Apply<X>;
export declare type InputOf<F extends Kind> = Kind.InputOf<F>;
export declare type OutputOf<F extends Kind> = Kind.OutputOf<F>;
declare const Kind_: typeof Kind;
export declare abstract class Kind<F extends Function = Function> {
    abstract readonly [Kind_._]: unknown;
    abstract f: F;
}
export default Kind;
